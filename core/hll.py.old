# src/hllset_swarm/hll.py
from julia import Main, Julia
# Julia.install()

import os
from pathlib import Path
from typing import Optional, Tuple, Dict, Any, List, Union
from dataclasses import dataclass

# Auto-detect HllSets.jl path if not set
hllsets_path = os.getenv("HLLSETS_PATH")

if not hllsets_path:
    # Try to find HllSets.jl relative to this file
    current_dir = Path(__file__).parent
    hllsets_jl = current_dir / "HllSets.jl"
    
    if hllsets_jl.exists():
        hllsets_path = str(hllsets_jl)
    else:
        raise EnvironmentError(
            f"HLLSETS_PATH environment variable is not set and HllSets.jl not found at {hllsets_jl}"
        )

# Load the HllSets.jl file
Main.include(hllsets_path)
Main.using(".HllSets")

from .constants import P_BITS
from .constants import SHARED_SEED, HASH_FUNC

@dataclass
class AddResult:
    """Result from adding a token to HLL"""
    token: str
    hash_value: int
    register: int
    leading_zeros: int
    
class HLL:
    def __init__(self, P_BITS: int = P_BITS):
        self.P = P_BITS
        self.hll = Main.HllSet(P_BITS)
        
    # def add(self, token: str, seed: int = SHARED_SEED):
    #     add_func = getattr(Main, "add!")
    #     return add_func(self.hll, token, seed=seed)
    #     # Main.add!(self.jl, token, seed=SHARED_SEED)

    def add(self, token: Union[str, List[str]], seed: int = SHARED_SEED) -> Union[AddResult, List[AddResult], None]:
        """
        Add token(s) to the HLL set
        
        Args:
            token: Single token (str) or list of tokens
            seed: Hash seed value
            
        Returns:
            - AddResult: if single token
            - List[AddResult]: if list of tokens
            - None: if token is empty
        """
        add_func = getattr(Main, "add!")
        
        # Handle single token
        if isinstance(token, str):
            result = add_func(self.hll, token, seed=seed)
            if result is None:
                return None
            return self._parse_add_result(result)
        
        # Handle list of tokens
        elif isinstance(token, (list, tuple)):
            results = add_func(self.hll, token, seed=seed)
            if results is None:
                return None
            return [self._parse_add_result(r) for r in results]
        
        else:
            raise TypeError(f"Token must be str or list, got {type(token)}")
    
    def _parse_add_result(self, result: tuple) -> AddResult:
        """
        Parse the tuple returned by Julia add! function
        
        Args:
            result: Tuple (token, hash, register, leading_zeros)
            
        Returns:
            AddResult dataclass
        """
        if result is None or len(result) != 4:
            raise ValueError(f"Invalid add! result: {result}")
        
        token, hash_value, register, leading_zeros = result
        
        return AddResult(
            token=str(token),
            hash_value=int(hash_value),
            register=int(register),
            leading_zeros=int(leading_zeros)
        )

    def cardinality(self) -> float: 
        # Use counts register to estimate cardinality
        # For now, use the Julia HLL's internal estimate
        try:
            # Try to get the cardinality estimate from Julia
            return float(self.hll.cardinality)
        except:
            # Fallback: count number of non-zero registers
            return float(self._estimate_cardinality())
    
    def _estimate_cardinality(self) -> float:
        """Estimate cardinality from registers (simplified)."""
        # This is a rough estimate - real HLL uses harmonic mean
        # For now, just return the count of items we've added (stored internally)
        # In real implementation, this would decode the HLL registers
        return 0.0  # Will be overridden by the Julia object's cardinality

    # def dump(self) -> bytes: return bytes(Main.dump(self.hll))

    def dump(self) -> list:
        """
        Get the counts vector from the HLL set
        
        Returns:
            List of values representing the HLL
        """
        # Use string representation as deterministic content
        hll_str = str(self.hll)
        return [ord(c) for c in hll_str]
    
    def dump_numpy(self):
        """
        Get the counts vector as a numpy array
        
        Returns:
            numpy array representing the HLL content
        """
        import numpy as np
        # Use string representation as deterministic content
        hll_str = str(self.hll)
        return np.array([ord(c) for c in hll_str], dtype=np.uint32)

    def isempty(self) -> float: return float(Main.isempty(self.hll))

    def isequal(self, other: "HLL") -> float: return float(Main.isequal(self.hll, other.hll))

    def intersect(self, other: "HLL") -> "HLL":
        return HLL.from_julia(Main.intersect(self.hll, other.hll))
    
    def unite(self, other: "HLL") -> "HLL":

        union_func = getattr(Main, "Base.union")
        return union_func(self.hll, other.hll)
    
    def diff(self, other: "HLL") -> "HLL":
        return HLL.from_julia(Main.diff(self.hll, other.hll))  
    
    def cosine(self, other: "HLL") -> float:
        return float(Main.cosine(self.hll, other.hll))  
    
    def similarity(self, other: "HLL") -> float:
        return float(Main.match(self.hll, other.hll))

    def hll_id(self) -> str:
        return str(Main.hll_id(self.hll))

    def get_register_vector(self):
        """Get the register counts as a list."""
        try:
            counts = Main.counts(self.hll)
            return list(counts)
        except:
            return []  
    
    @staticmethod
    def from_julia(hll): h = HLL(); h.hll = hll; return h
    
    def clone(self) -> 'HLL':
        """
        Create a deep copy of this HLL.
        
        Returns:
            New HLL instance with copied state
        """
        # Create new HLL with same precision
        h = HLL(self.P)
        # Copy the Julia HllSet (Julia objects are immutable by default)
        # We create a new one from the register counts
        try:
            counts = Main.counts(self.hll)
            # Create new HLL from counts - this creates a copy
            h.hll = Main.HllSet(self.P, counts=counts)
        except:
            # Fallback: create new HLL and manually copy
            h.hll = Main.HllSet(self.P)
        return h