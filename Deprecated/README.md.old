# hllset_manifold

This project is a generalization of the concept of SGS.ai, HLLSet, and Entanglement as foundation for AI models. It is built on other projects presented in this repository. The initial code and project layout was generated by Copilot.

## Overview

`hllset_manifold` is a Python library that implements a mathematical framework for manifolds with morphisms and entanglement. This framework addresses six key requirements:

1. **Manifolds** - The fundamental mathematical structure
2. **Idempotency** - The only restriction exposed
3. **Morphisms** (hash functions) - Not separated by type except during disambiguation
4. **Disambiguation** - Separation by morphism types only when needed
5. **Entanglement** - Implemented as automorphism in manifold
6. **Tangent Vectors** - For any morphism m: H₁ → H₂, define m' = {D, R, N} and m'ₜ = (dD/dt, dR/dt, dN/dt)

## Installation

```bash
pip install -e .
```

For development:

```bash
pip install -e ".[dev]"
```

## Core Concepts

### Manifold

A manifold is the fundamental structure with idempotency as its only restriction:

```python
from hllset_manifold import Manifold

# Create a manifold
m = Manifold("MyManifold")

# Add elements (idempotent operation)
m.add_element("element1")
m.add_element("element1")  # Adding again has no effect
assert len(m) == 1

# Check element membership
assert m.contains("element1")
```

### Morphism

Morphisms are hash functions that map between manifolds. They are not separated by type:

```python
from hllset_manifold import Morphism

# Create a morphism from H1 to H2
m = Morphism("H1", "H2")

# Apply the morphism
result = m("input_value")

# Morphisms can be composed
m1 = Morphism("H1", "H2")
m2 = Morphism("H2", "H3")
m_composed = m1.compose(m2)
```

### Disambiguation

Morphisms only need type separation during disambiguation:

```python
# Create morphisms without type labels
m1 = Morphism("H1", "H2", name="morph1")
m2 = Morphism("H1", "H2", name="morph2")

# They work without disambiguation
result1 = m1("test")
result2 = m2("test")

# When disambiguation is needed
m1.set_disambiguation_type("type_A")
m2.set_disambiguation_type("type_B")
```

### Entanglement

Entanglement is an automorphism - a morphism from a manifold to itself:

```python
from hllset_manifold import Manifold, Entanglement

# Create manifold
m = Manifold("TestManifold")
m.add_element("a")
m.add_element("b")

# Create entanglement (automorphism)
e = Entanglement(m)

# Entangle elements
e.entangle("a", "b")
assert e.is_entangled("a", "b")

# Apply automorphism
result = e.apply_automorphism("a")
```

### Tangent Vectors

For any morphism m: H₁ → H₂, we can define tangent vectors:

```python
from hllset_manifold import TangentVector, Morphism
from hllset_manifold.tangent_vector import MorphismTangentSpace

# Create morphism
m = Morphism("H1", "H2", name="test_morph")

# Create tangent space
tangent_space = MorphismTangentSpace(m.name)

# Set tangent vector m' = {D, R, N}
m_prime = TangentVector(D=1.0, R=2.0, N=3.0)
tangent_space.set_tangent_vector(m_prime)

# Define time derivative m'ₜ = (dD/dt, dR/dt, dN/dt)
def derivative_func(t):
    return TangentVector(D=0.5*t, R=1.0*t, N=1.5*t)

tangent_space.set_derivative_function(derivative_func)

# Get derivative at time t
m_prime_t = tangent_space.get_derivative_at(2.0)
```

## Complete Example

```python
from hllset_manifold import Manifold, Morphism, Entanglement, TangentVector
from hllset_manifold.tangent_vector import MorphismTangentSpace

# Create two manifolds
h1 = Manifold("H1")
h2 = Manifold("H2")

# Add elements to source manifold
h1.add_element("point1")
h1.add_element("point2")

# Create morphism between manifolds
morphism = Morphism("H1", "H2", name="transform")

# Apply morphism to map elements
result1 = morphism("point1")
result2 = morphism("point2")
h2.add_element(result1)
h2.add_element(result2)

# Create entanglement in source manifold
entanglement = Entanglement(h1)
entanglement.entangle("point1", "point2")

# Define tangent vectors for the morphism
tangent_space = MorphismTangentSpace(morphism.name)
tangent_vector = TangentVector(D=1.0, R=2.0, N=3.0)
tangent_space.set_tangent_vector(tangent_vector)

# Get time derivative
derivative = tangent_vector.derivative(d_D_dt=0.1, d_R_dt=0.2, d_N_dt=0.3)
print(f"Derivative: {derivative}")
```

## API Reference

### Manifold

- `__init__(name: Optional[str])` - Create a manifold
- `add_element(element: Any) -> bool` - Add element (idempotent)
- `contains(element: Any) -> bool` - Check if element exists
- `get_elements() -> Set[Any]` - Get all elements
- `set_structure(key: str, value: Any)` - Set structural property
- `get_structure(key: str) -> Optional[Any]` - Get structural property

### Morphism

- `__init__(source_id: str, target_id: str, hash_func: Optional[Callable], name: Optional[str])` - Create morphism
- `apply(value: Any) -> str` - Apply morphism to value
- `set_disambiguation_type(type_label: str)` - Set disambiguation type
- `get_disambiguation_type() -> Optional[str]` - Get disambiguation type
- `compose(other: Morphism) -> Morphism` - Compose with another morphism

### Entanglement

- `__init__(manifold: Manifold, name: Optional[str])` - Create entanglement
- `entangle(element1: Any, element2: Any)` - Entangle two elements
- `is_entangled(element1: Any, element2: Any) -> bool` - Check if entangled
- `get_entangled_with(element: Any) -> List[Any]` - Get elements entangled with given element
- `apply_automorphism(element: Any) -> str` - Apply automorphism
- `get_automorphism() -> Morphism` - Get underlying automorphism

### TangentVector

- `__init__(D: float, R: float, N: float)` - Create tangent vector with {D, R, N} components
- `derivative(d_D_dt: float, d_R_dt: float, d_N_dt: float) -> TangentVector` - Calculate time derivative
- `magnitude() -> float` - Calculate vector magnitude
- `normalize() -> TangentVector` - Normalize to unit length
- `dot(other: TangentVector) -> float` - Dot product
- `cross(other: TangentVector) -> TangentVector` - Cross product
- `scale(scalar: float) -> TangentVector` - Scale by scalar
- `add(other: TangentVector) -> TangentVector` - Add vectors

### MorphismTangentSpace

- `__init__(morphism_name: str)` - Create tangent space for morphism
- `set_tangent_vector(vector: TangentVector)` - Set current tangent vector
- `set_derivative_function(func: Callable[[float], TangentVector])` - Set time derivative function
- `get_derivative_at(t: float) -> Optional[TangentVector]` - Get derivative at time t

## Testing

Run the test suite:

```bash
pytest tests/ -v
```

## License

MIT License - see LICENSE file for details.

## Requirements Addressed

This implementation addresses all six requirements from the problem statement:

1. ✅ **Manifolds** - Implemented as the `Manifold` class with structural properties
2. ✅ **Idempotency** - The only restriction, enforced in `add_element()` and entanglement operations
3. ✅ **Morphisms not separated** - Morphisms work without type labels by default
4. ✅ **Disambiguation when needed** - Type separation available via `set_disambiguation_type()`
5. ✅ **Entanglement as automorphism** - `Entanglement` class implements automorphism (manifold→itself)
6. ✅ **Tangent vectors** - `TangentVector` with {D, R, N} components and time derivatives m'ₜ = (dD/dt, dR/dt, dN/dt)
